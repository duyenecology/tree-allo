---
title: "Comparing H models (updated)"
author: "Masatoshi Katabuchi"
date: "`r format(Sys.time(), '%B %d, %Y')`"
fontsize: 12pt
format:
  html:
    theme: coderpro
    toc: true
    toc-depth: 2
    number-sections: true
    smooth-scroll: true
    standalone: true
    embed-resources: true
---

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = "/workspaces/tree-allometry")
```

```{r global_options, include=FALSE}
library(knitr)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE,
  cache = FALSE,
  fig.align = "center",
  fig.show = "hold"
)
```

```{r, include=FALSE}
library(targets)
library(tidyverse)
library(scales)
```

```{r}
pl_summary <- tar_read(fit_lr2_summary_power_law1_h)
```

```{r}
##pl
gamma_pl <- pl_summary |> filter(grepl("gamma", variable))
gamma_pl

community_log_a_pl <- gamma_pl |> filter(variable == "gamma[1,1]") |> pull(q50)
community_b_pl <- gamma_pl |> filter(variable == "gamma[2,1]") |> pull(q50)
```

We need sd and mean to unscale DBH and H.
```{r}
tallo_wd_df_200 <- tar_read(tallo_wd_df_200)
# tallo_wd_df_200

data2 <- tallo_wd_df_200 |>
  filter(!is.na(dbh)) |>
  filter(!is.na(h)) |>
  filter(!is.na(cr)) |>
  filter(!is.na(wd_s))

data2 <- data2 |>
    mutate(log_dbh = log(dbh),
           log_h = log(h),
           log_cr = log(cr)) |>
    mutate(log_dbh_s = scale(log_dbh) |> as.numeric(),
           log_h_s = scale(log_h) |> as.numeric(),
           log_cr_s = scale(log_cr) |> as.numeric()) |>
    mutate(dbh_s = scale(dbh) |> as.numeric())

# we need sd and mean to unscale the values
log_dbh_sd <- sd(data2$log_dbh)
log_dbh_mean <- mean(data2$log_dbh)

log_h_sd <- sd(data2$log_h)
log_h_mean <- mean(data2$log_h)

stan_data_lr_h <- tar_read(stan_data_lr_h)
str(stan_data_lr_h)
```

We only need several data points for x to plot the line.
We can generate a sequence of x-values from the range of the scaled x-values.
We also need to unscale them to get the actual values.

```{r}
scaled_x_range <- stan_data_lr_h$log_x[, 2] |> range()
log_x_seq <- seq(scaled_x_range[1], scaled_x_range[2], length.out = 100)
log_xx <- (log_x_seq * log_dbh_sd) + log_dbh_mean
```

Because the predicted y-values are also scaled (according to `generate_stan_data`), we need to unscale them to get the actual values.
You didn't have to scale y-values for the model in the first place, but it's okay.

```{r}
# use scaled values to predict scaled values
log_y_pred_scaled <- community_log_a_pl + community_b_pl * log_x_seq
# unscaled
log_y_pred <- log_y_pred_scaled * log_h_sd + log_h_mean
y_pred <- exp(log_y_pred)

# use unscaled values to draw lines.
df <- tibble(y = y_pred, x = exp(log_xx))
```

For the desnity plot, you can use other functions but here is a simple example.
```{r}
ggplot() +
  geom_bin2d(data = data2, aes(x = dbh, y = h), bins = 100)  +
  scale_fill_viridis_c(option = "D") +
  geom_line(data = df, aes(x = x, y = y))
```
