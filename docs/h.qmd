---
title: "Plot the best model to predict H from DBH: Weibull"
author: "Nguyen Thi Duyen"
date: "`r format(Sys.time(), '%B %d, %Y')`"
fontsize: 12pt
format:
  html:
    theme: coderpro
    toc: true
    toc-depth: 2
    number-sections: true
    smooth-scroll: true
    standalone: true
    embed-resources: true
---

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = "/workspaces/tree-allometry")
```

```{r global_options, include=FALSE}
library(knitr)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE,
  cache = FALSE,
  fig.align = "center",
  fig.show = "hold"
)
```

```{r, include=FALSE}
library(targets)
library(dplyr)
library(ggplot2)
library(stringr)
library(reshape2)
library(scales)
```

# Read in data
```{r}
# Read in the data
stan_data_nlr_h <- tar_read(stan_data_nlr_h)
str(stan_data_nlr_h)

# Extract relevant data
log_y <- stan_data_nlr_h$log_y
x <- stan_data_nlr_h$x
sp <- as.factor(stan_data_nlr_h$jj)

# Read in the model summary
wb1_h_summary <- tar_read(fit_nlr_summary_weibull1_h)
wb1_h_summary

# Extract the actual beta parameters
beta <- wb1_h_summary |> filter(grepl("beta\\[", variable))
beta

log_a <- beta |> filter(str_detect(variable, "beta\\[\\d+,1\\]")) |> pull(q50)
b <- beta |> filter(str_detect(variable, "beta\\[\\d+,2\\]")) |> pull(q50)
k <- beta |> filter(str_detect(variable, "beta\\[\\d+,3\\]")) |> pull(q50)

# Compute fitted values for H using the Weibull formula
fitted_log_y_h <- sapply(1:length(log_a), function(i) {
  log_a[i] + log(1 - exp(-b[i] * (x ^ k[i])))
})

fitted_h <- exp(fitted_log_y_h)

# Extract community-level parameters directly
gamma <- wb1_h_summary |> filter(grepl("gamma", variable))

# Correctly map community parameters
community_log_a_hat <- gamma |> filter(variable == "gamma[1,1]") |> pull(q50)
community_b_hat <- gamma |> filter(variable == "gamma[1,2]") |> pull(q50)
community_k_hat <- gamma |> filter(variable == "gamma[1,3]") |> pull(q50)

# Apply exponential transformation to community-level parameters
community_log_a <- exp(community_log_a_hat)
community_b <- exp(community_b_hat) 
community_k <- exp(community_k_hat)


community_fitted_log_y_h <- community_log_a + log(1 - exp(-community_b * (x^community_k)))
community_fitted_H <- exp(community_fitted_log_y_h)

# Create a data frame for plotting
data_h <- data.frame(H = exp(log_y), DBH = x, sp = sp)
data_h$community_fitted_H <- community_fitted_H
head(data_h)

# Add species-specific fitted values to the data frame
for (i in 1:length(log_a)) {
  data_h[[paste0("fitted_H_sp_", i)]] <- fitted_h[, i]
}

# Convert data to long format
data_long <- reshape2::melt(data_h, id.vars = c("H", "DBH", "sp", "community_fitted_H"), measure.vars = grep("fitted_H_sp_", names(data_h), value = TRUE))

head(data_long)

# Function to create DBH sequence for each species based on actual range
create_dbh_sequence <- function(species, x, length_out = 100) {
  min_dbh <- min(x[sp == species])
  max_dbh <- max(x[sp == species])
  seq(min_dbh, max_dbh, length.out = length_out)
}

# Calculate fitted H values for each species
fitted_h_list <- lapply(1:length(log_a), \(i) {
  dbh_seq <- create_dbh_sequence(i, x)
  fitted_log_y <- log_a[i] + log(1 - exp(-b[i] * (dbh_seq ^ k[i])))
  fitted_h <- exp(fitted_log_y)
  
  data.frame(
    DBH = dbh_seq,
    value = fitted_h,
    variable = paste0("fitted_H_sp_", i)
  )
})

# Combine all species data frames into one
data_long <- do.call(rbind, fitted_h_list)
head(data_long)

# Original data for points
data_h <- data.frame(H = exp(log_y), DBH = x, sp = sp)
head(data_h)
```

# Plot
```{r}
wb1_h_plot1 <- ggplot(data_h, aes(x = DBH, y = H)) +
  # geom_point(alpha = 0.5, color = "grey") +
  geom_line(data = data_long, aes(x = DBH, y = value, group = variable), color = "#72b6e3", alpha = 0.5) +
  geom_line(aes(y = community_fitted_H), color = "#0f92e9", linewidth = 1.5) +
  labs(
       x = "DBH (cm)",
       y = "H (m)") +
  scale_x_log10(labels = scales::label_number()) +
  scale_y_log10(labels = scales::label_number()) +
  theme_minimal()

wb1_h_plot1
```
