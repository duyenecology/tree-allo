---
title: "Crown radius/Height vs DBH: size range of sample"
author: "Nguyen Thi Duyen"
date: "`r format(Sys.time(), '%B %d, %Y')`"
fontsize: 12pt
format:
  html:
    theme: coderpro
    toc: true
    toc-depth: 2
    number-sections: true
    smooth-scroll: true
    standalone: true
    embed-resources: true
---

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = "/workspaces/tree-allometry")
```

```{r global_options, include=FALSE}
library(knitr)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE,
  cache = FALSE,
  fig.align = "center",
  fig.show = "hold"
)
```

# Load necessary libraries
```{r}
library(targets)
library(ggplot2)
library(MASS) # For kde2d function
library(scales)
library(dplyr)
library(stringr)
library(reshape2)
# Define and run the targets pipeline
# tar_make()
```

# H-DBH

## Data preparation

```{r}
# Read in the data
stan_data_nlr_h <- tar_read(stan_data_nlr_h)
str(stan_data_nlr_h)

# Extract relevant data
log_y <- stan_data_nlr_h$log_y
x <- stan_data_nlr_h$x
sp <- as.factor(stan_data_nlr_h$jj)

# Read in the model summary
wb1_h_summary <- tar_read(fit_nlr_summary_weibull1_h)
wb1_h_summary

# Extract the actual beta parameters
beta <- wb1_h_summary |> filter(grepl("beta\\[", variable))
beta

log_a <- beta |> filter(str_detect(variable, "beta\\[\\d+,1\\]")) |> pull(mean)
b <- beta |> filter(str_detect(variable, "beta\\[\\d+,2\\]")) |> pull(mean)
k <- beta |> filter(str_detect(variable, "beta\\[\\d+,3\\]")) |> pull(mean)

# Compute fitted values for H using the Weibull formula
fitted_log_y_h <- sapply(1:length(log_a), function(i) {
  log_a[i] + log(1 - exp(-b[i] * (x ^ k[i])))
})

fitted_h <- exp(fitted_log_y_h)

# Extract community-level parameters directly
gamma <- wb1_h_summary |> filter(grepl("gamma", variable))

# Correctly map community parameters
community_log_a_hat <- gamma |> filter(variable == "gamma[1,1]") |> pull(mean)
community_b_hat <- gamma |> filter(variable == "gamma[1,2]") |> pull(mean)
community_k_hat <- gamma |> filter(variable == "gamma[1,3]") |> pull(mean)

# Apply exponential transformation to community-level parameters
community_log_a <- exp(community_log_a_hat)
community_b <- exp(community_b_hat) 
community_k <- exp(community_k_hat)


community_fitted_log_y_h <- community_log_a + log(1 - exp(-community_b * (x^community_k)))
community_fitted_H <- exp(community_fitted_log_y_h)

# Create a data frame for plotting
data_h <- data.frame(H = exp(log_y), DBH = x, sp = sp)
data_h$community_fitted_H <- community_fitted_H
head(data_h)
```


## Density plotting
```{r}
# Compute density using kde2d function
dens <- with(data_h, kde2d(log(DBH), log(H), n = 150))
ix <- findInterval(log(data_h$DBH), dens$x)
iy <- findInterval(log(data_h$H), dens$y)
data_h$density <- dens$z[cbind(ix, iy)]

# Plot with points and density-based coloring
plot_h_density_points <- ggplot(data_h, aes(x = DBH, y = H, color = density)) +
  geom_point(size = 0.5, alpha = 0.8) +
  scale_color_gradientn(colors = c("black", "purple", "orange", "yellow"), name = "Density") +
  scale_x_log10(labels = scales::label_number()) +
  scale_y_log10(labels = scales::label_number()) +
  labs(x = " DBH (cm)", y = " H (m)") +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 15, face = "bold"),
    axis.text = element_text(size = 12),
    panel.grid = element_blank(),
    legend.position = "none"
  )

# Save the plot
ggsave(filename = "figs/h/H_DBH_density.png", plot = plot_h_density_points, width = 12, height = 8, dpi = 300, bg = "white")

print(plot_h_density_points)
```


## Plot 3 function in 1 panel with density based coloring

```{r}
tallo_wd_df_200 <- tar_read(tallo_wd_df_200)
tallo_wd_df_200

data2 <- tallo_wd_df_200 |>
    filter(!is.na(dbh)) |>
    filter(!is.na(h)) |>
    filter(!is.na(cr)) |>
    filter(!is.na(wd_s))

data2 <- data2 |>
    mutate(log_dbh = log(dbh),
           log_h = log(h),
           log_cr = log(cr)) |>
    mutate(log_dbh_s = scale(log_dbh) |> as.numeric(),
           log_h_s = scale(log_h) |> as.numeric(),
           log_cr_s = scale(log_cr) |> as.numeric()) |>
    mutate(dbh_s = scale(dbh) |> as.numeric())


data2

# Extract scaling parameters for unscaling
scaling_params <- data2 |>
    summarise(mean_log_dbh = mean(log_dbh), sd_log_dbh = sd(log_dbh),
              mean_log_h = mean(log_h), sd_log_h = sd(log_h))

scaling_params


# Functions for scaling and unscaling based on log-transformed values
scale_log_dbh <- function(log_dbh) (log_dbh - scaling_params$mean_log_dbh) / scaling_params$sd_log_dbh
unscale_log_h <- function(log_h_scaled) (log_h_scaled * scaling_params$sd_log_h) + scaling_params$mean_log_h

# Read in the data (power-law)
stan_data_lr_h <- tar_read(stan_data_lr_h)
log_y_lr <- stan_data_lr_h$log_y
log_x_lr <- stan_data_lr_h$log_x[, 2]
sp_lr <- as.factor(stan_data_lr_h$jj)

head(log_y_lr)
head(log_x_lr)

# Unscale log-transformed DBH and height for the power-law model
unscaled_log_dbh_pl <- (log_x_lr * scaling_params$sd_log_dbh) + scaling_params$mean_log_dbh
unscaled_log_h_pl <- (log_y_lr * scaling_params$sd_log_h) + scaling_params$mean_log_h

head(unscaled_log_dbh_pl)
head(unscaled_log_h_pl)

# Read in the data (gMM, Weibull)
stan_data_nlr_h <- tar_read(stan_data_nlr_h)
log_y_nlr <- stan_data_nlr_h$log_y
x_nlr <- stan_data_nlr_h$x
sp_nlr <- as.factor(stan_data_nlr_h$jj)

# Read in the model summaries for generalized Michaelis-Menten (gMM), Weibull (wb), and power-law (pl)
gmm_summary <- tar_read(fit_nlr_summary_gmm1_h)
wb_summary <- tar_read(fit_nlr_summary_weibull1_h)
pl_summary <- tar_read(fit_lr2_summary_power_law1_h)

gmm_summary
wb_summary
pl_summary


# Extract community-level parameters for power-law
gamma_pl <- pl_summary |> filter(grepl("gamma", variable))
community_log_a_pl <- gamma_pl |> filter(variable == "gamma[1,1]") |> pull(mean)
community_b_pl <- gamma_pl |> filter(variable == "gamma[2,1]") |> pull(mean)

# Compute fitted values for power-law model using scaled log(DBH)
community_fitted_log_y_h_pl <- community_log_a_pl + community_b_pl * scale_log_dbh(unscaled_log_dbh_pl)
community_fitted_h_pl <- exp(unscale_log_h(community_fitted_log_y_h_pl))


# Extract community-level parameters for gMM
gamma_gmm <- gmm_summary |> filter(grepl("gamma", variable))
community_log_a_hat_gmm <- gamma_gmm |> filter(variable == "gamma[1,1]") |> pull(mean)
community_b_hat_gmm <- gamma_gmm |> filter(variable == "gamma[1,2]") |> pull(mean)
community_k_hat_gmm <- gamma_gmm |> filter(variable == "gamma[1,3]") |> pull(mean)

community_log_a_gmm <- exp(community_log_a_hat_gmm)
community_b_gmm <- exp(community_b_hat_gmm)
community_k_gmm <- exp(community_k_hat_gmm)

community_fitted_log_y_h_gmm <- community_log_a_gmm + community_b_gmm * log(x_nlr) - log(community_k_gmm + x_nlr^community_b_gmm)
community_fitted_h_gmm <- exp(community_fitted_log_y_h_gmm)

head(community_fitted_h_gmm)


# Extract community-level parameters for Weibull
gamma_wb <- wb_summary |> filter(grepl("gamma", variable))
community_log_a_hat_wb <- gamma_wb |> filter(variable == "gamma[1,1]") |> pull(mean)
community_b_hat_wb <- gamma_wb |> filter(variable == "gamma[1,2]") |> pull(mean)
community_k_hat_wb <- gamma_wb |> filter(variable == "gamma[1,3]") |> pull(mean)

community_log_a_wb <- exp(community_log_a_hat_wb)
community_b_wb <- exp(community_b_hat_wb)
community_k_wb <- exp(community_k_hat_wb)

community_fitted_log_y_h_wb <- community_log_a_wb + log(1 - exp(-community_b_wb * (x_nlr ^ community_k_wb)))
community_fitted_h_wb <- exp(community_fitted_log_y_h_wb)

head(community_fitted_h_wb)

# Create a data frame for plotting
data_h_pl_unscaled <- data.frame(H = exp(unscaled_log_h_pl), DBH = exp(unscaled_log_dbh_pl), sp = as.factor(stan_data_lr_h$jj), community_fitted_H_pl = community_fitted_h_pl)

head(data_h_pl_unscaled)

data_h_gb <- data.frame(H = exp(log_y_nlr), DBH = x_nlr, sp = sp_nlr)
head(data_h_gb)

data_h_gb$community_fitted_H_gmm <- community_fitted_h_gmm
data_h_gb$community_fitted_H_wb <- community_fitted_h_wb

head(data_h_pl_unscaled)
head(data_h_gb)


# Combine the data frames
data_combined <- merge(data_h_pl_unscaled, data_h_gb, by = "sp", all = TRUE)
head(data_combined)

# Separate the community-fitted values for plotting
data_community_pl <- data_combined |> select(DBH.x, community_fitted_H_pl) |> distinct()
data_community_gmm <- data_combined |> select(DBH.y, community_fitted_H_gmm) |> distinct()
data_community_wb <- data_combined |> select(DBH.y, community_fitted_H_wb) |> distinct()

head(data_community_pl)
head(data_community_gmm)
```

## Log scale plot with density based coloring (non-log scale)

```{r}
library(MASS)
library(dplyr)

head(data_combined)

dens <- with(data_combined, kde2d(log(DBH.y), log(H.y), n = 150))
ix <- findInterval(log(data_combined$DBH.y), dens$x)
iy <- findInterval(log(data_combined$H.y), dens$y)
data_combined$density <- dens$z[cbind(ix, iy)]

head(data_combined)

# Plotting the three functions in one panel with density-based coloring for points
combined_plot <- ggplot(data_combined) +
  geom_point(aes(x = DBH.y, y = H.y, color = density), size = 0.5, alpha = 0.8) +
  geom_line(aes(x = DBH.x, y = community_fitted_H_pl), color = "blue", size = 1, data = data_community_pl) +
  geom_line(aes(x = DBH.y, y = community_fitted_H_gmm), color = "red", size = 1, data = data_community_gmm) +
  geom_line(aes(x = DBH.y, y = community_fitted_H_wb), color = "green", size = 1, data = data_community_wb) +
  labs(title = "Community-level Model Fits for Power-law, gMM, and Weibull Models",
       x = "DBH (cm)",
       y = "H (m)") +
  scale_x_log10(labels = scales::label_number()) +
  scale_y_log10(labels = scales::label_number()) +
  scale_color_gradientn(colors = c("black", "purple", "orange", "yellow"), name = "Density") +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 15),
    axis.text = element_text(size = 12),
    panel.grid = element_blank(),
    legend.position = "none"
  )

# Save the plot
ggsave(filename = "figs/h/DBH_H_community_combined_with_density.png", plot = combined_plot, width = 12, height = 8, dpi = 300, bg = "white")
```

## Non-log scale plot with density based coloring 

```{r}
# Plotting with a smoother density representation
combined_plot2 <- ggplot(data_combined, aes(x = DBH.y, y = H.y, color = density)) +
  geom_point(size = 0.5, alpha = 0.8) +
  geom_line(aes(x = DBH.x, y = community_fitted_H_pl), color = "blue", size = 1, data = data_community_pl) +
  geom_line(aes(x = DBH.y, y = community_fitted_H_gmm), color = "red", size = 1, data = data_community_gmm) +
  geom_line(aes(x = DBH.y, y = community_fitted_H_wb), color = "green", size = 1, data = data_community_wb) +
  labs(title = "Community-level Model Fits for Power-law, gMM, and Weibull Models",
       x = "DBH (cm)",
       y = "H (m)") +
  scale_color_gradientn(colors = c("black", "purple", "orange", "yellow"), name = "Density") +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 15),
    axis.text = element_text(size = 12),
    panel.grid = element_blank(),
    legend.position = "none"
  )


# Save the plot
ggsave(filename = "figs/h/DBH_H_community_combined_non_log.png", plot = combined_plot2, width = 12, height = 8, dpi = 300, bg = "white")

```



# CR-DBH

## Data preparation
```{r}
# Read in the data (wb, gMM)
stan_data_nlr_cr <- tar_read(stan_data_nlr_cr)
str(stan_data_nlr_cr)

# Extract relevant data 
log_y <- stan_data_nlr_cr$log_y
x <- stan_data_nlr_cr$x
sp <- as.factor(stan_data_nlr_cr$jj)

# Read in the model summary
options(width = 120)
wb1_cr_summary <- tar_read(fit_nlr_summary_weibull1_cr)
wb1_cr_summary

# Extract the actual beta parameters
beta <- wb1_cr_summary |> filter(grepl("beta\\[", variable))
beta

log_a <- beta |> filter(str_detect(variable, "beta\\[\\d+,1\\]")) |> pull(mean)
b <- beta |> filter(str_detect(variable, "beta\\[\\d+,2\\]")) |> pull(mean)
k <- beta |> filter(str_detect(variable, "beta\\[\\d+,3\\]")) |> pull(mean)


# Compute fitted values for CR using the Weibull formula
fitted_log_y_cr <- sapply(1:length(log_a), function(i) {
  log_a[i] + log(1 - exp(-b[i] * (x ^ k[i])))
})

fitted_cr <- exp(fitted_log_y_cr)

# Extract community-level parameters directly
gamma <- wb1_cr_summary |> filter(grepl("gamma", variable))

# Correctly map community parameters
community_log_a_hat <- gamma |> filter(variable == "gamma[1,1]") |> pull(mean)
community_b_hat <- gamma |> filter(variable == "gamma[1,2]") |> pull(mean)
community_k_hat <- gamma |> filter(variable == "gamma[1,3]") |> pull(mean)

# Apply exponential transformation to community-level parameters
community_log_a <- exp(community_log_a_hat)
community_b <- exp(community_b_hat) 
community_k <- exp(community_k_hat)

community_fitted_log_y_cr <- community_log_a + log(1 - exp(-community_b * (x^community_k)))
community_fitted_CR <- exp(community_fitted_log_y_cr)

# Create a data frame for plotting
data_cr <- data.frame(CR = exp(log_y), DBH = x, sp = sp)
data_cr$community_fitted_CR <- community_fitted_CR
head(data_cr)

```

## Density plotting

```{r}
# Compute density using kde2d function
dens <- with(data_cr, kde2d(log(DBH), log(CR), n = 100))
ix <- findInterval(log(data_cr$DBH), dens$x)
iy <- findInterval(log(data_cr$CR), dens$y)
data_cr$density <- dens$z[cbind(ix, iy)]

# Plot with points and density-based coloring
plot_cr_density_points <- ggplot(data_cr, aes(x = DBH, y = CR, color = density)) +
  geom_point(size = 0.5, alpha = 0.8) +
  scale_color_gradientn(colors = c("black", "purple", "orange", "yellow"), name = "Density") +
  scale_x_log10(labels = scales::label_number()) +
  scale_y_log10(labels = scales::label_number()) +
  labs(x = " DBH (cm)", y = " CR (m)") +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 15, face = "bold"),
    axis.text = element_text(size = 12),
    panel.grid = element_blank(),
    legend.position = "none"
  )

# Save the plot
ggsave(filename = "figs/cr/CR_DBH_density.png", plot = plot_cr_density_points, width = 12, height = 8, dpi = 300, bg = "white")

print(plot_cr_density_points)
```

## Plot 3 functions in 1 panel with density-based coloring (log scale)

```{r}
tallo_wd_df_200 <- tar_read(tallo_wd_df_200)
tallo_wd_df_200

data2 <- tallo_wd_df_200 |>
    filter(!is.na(dbh)) |>
    filter(!is.na(cr)) |>
    filter(!is.na(h)) |>
    filter(!is.na(wd_s))

data2 <- data2 |>
    mutate(log_dbh = log(dbh),
           log_h = log(h),
           log_cr = log(cr)) |>
    mutate(log_dbh_s = scale(log_dbh) |> as.numeric(),
           log_h_s = scale(log_h) |> as.numeric(),
           log_cr_s = scale(log_cr) |> as.numeric()) |>
    mutate(dbh_s = scale(dbh) |> as.numeric())


data2

# Extract scaling parameters for unscaling
scaling_params <- data2 |>
    summarise(mean_log_dbh = mean(log_dbh), sd_log_dbh = sd(log_dbh),
              mean_log_cr = mean(log_cr), sd_log_cr = sd(log_cr))

scaling_params

scale_log_dbh <- function(log_dbh) (log_dbh - scaling_params$mean_log_dbh) / scaling_params$sd_log_dbh
unscale_log_cr <- function(log_cr_scaled) (log_cr_scaled * scaling_params$sd_log_cr) + scaling_params$mean_log_cr


# Read in the data (pl)
stan_data_lr_cr <- tar_read(stan_data_lr_cr)
str(stan_data_lr_cr)

# Extract relevant data from stan_data_lr_cr (log_y, x, jj)
log_y_lr <- stan_data_lr_cr$log_y
log_x_lr <- stan_data_lr_cr$log_x[, 2]
sp_lr <- as.factor(stan_data_lr_cr$jj)

str(log_y_lr)
str(log_x_lr)
str(sp_lr)


# Unscale log-transformed DBH and height for the power-law model
unscaled_log_dbh_pl <- (log_x_lr * scaling_params$sd_log_dbh) + scaling_params$mean_log_dbh
unscaled_log_cr_pl <- (log_y_lr * scaling_params$sd_log_cr) + scaling_params$mean_log_cr

head(unscaled_log_dbh_pl)
head(unscaled_log_cr_pl)


# Read in the data (gMM, wb)
stan_data_nlr_cr <- tar_read(stan_data_nlr_cr)
str(stan_data_nlr_cr)

# Extract relevant data from stan_data_nlr_cr (log_y, x, jj)
log_y_nlr <- stan_data_nlr_cr$log_y
x_nlr <- stan_data_nlr_cr$x
sp_nlr <- as.factor(stan_data_nlr_cr$jj)

str(log_y_nlr)
str(x_nlr)


# Read in the model summaries for generalized Michaelis-Menten (gMM), Weibull (wb), and power-law (pl)
gmm_summary <- tar_read(fit_nlr_summary_gmm1_cr)
wb_summary <- tar_read(fit_nlr_summary_weibull1_cr)
pl_summary <- tar_read(fit_lr2_summary_power_law1_cr)

pl_summary
gamma_pl <- pl_summary |> filter(grepl("gamma", variable))
gamma_pl

community_log_a_pl <- gamma_pl |> filter(variable == "gamma[1,1]") |> pull(mean)
community_b_pl <- gamma_pl |> filter(variable == "gamma[2,1]") |> pull(mean)

community_log_a_pl
community_b_pl

## gMM
gmm_summary
gamma_gmm <- gmm_summary |> filter(grepl("gamma", variable))
gamma_gmm
community_log_a_hat_gmm <- gamma_gmm |> filter(variable == "gamma[1,1]") |> pull(mean)
community_b_hat_gmm <- gamma_gmm |> filter(variable == "gamma[1,2]") |> pull(mean)
community_k_hat_gmm <- gamma_gmm |> filter(variable == "gamma[1,3]") |> pull(mean)

community_log_a_gmm <- exp(community_log_a_hat_gmm)
community_b_gmm <- exp(community_b_hat_gmm) 
community_k_gmm <- exp(community_k_hat_gmm)

community_log_a_gmm
community_b_gmm
community_k_gmm

# Weibull
wb_summary
gamma_wb <- wb_summary |> filter(grepl("gamma", variable))
gamma_wb
community_log_a_hat_wb <- gamma_wb |> filter(variable == "gamma[1,1]") |> pull(mean)
community_b_hat_wb <- gamma_wb |> filter(variable == "gamma[1,2]") |> pull(mean)
community_k_hat_wb <- gamma_wb |> filter(variable == "gamma[1,3]") |> pull(mean)

community_log_a_wb <- exp(community_log_a_hat_wb)
community_b_wb <- exp(community_b_hat_wb) 
community_k_wb <- exp(community_k_hat_wb)

community_log_a_wb
community_b_wb
community_b_wb


# Computing Fitted Values for Community-level Parameters
#pl
community_fitted_log_y_cr_pl <- community_log_a_pl + community_b_pl * scale_log_dbh(unscaled_log_dbh_pl)
community_fitted_cr_pl <- exp(unscale_log_cr(community_fitted_log_y_cr_pl))

head(community_fitted_cr_pl)

# head(data2$log_dbh)
# head(unscaled_log_dbh_pl)
# head(scale_log_dbh(unscaled_log_dbh_pl))

#gMM 

community_fitted_log_y_cr_gmm <- community_log_a_gmm + community_b_gmm * log(x_nlr) - log(community_k_gmm + x_nlr^community_b_gmm)
community_fitted_cr_gmm <- exp(community_fitted_log_y_cr_gmm)

head(community_fitted_cr_gmm)

# wb

community_fitted_log_y_cr_wb <- community_log_a_wb + log(1 - exp(-community_b_wb * (x_nlr ^ community_k_wb)))
community_fitted_cr_wb <- exp(community_fitted_log_y_cr_wb)

head(community_fitted_cr_wb)

# Create a data frame for plotting
data_cr_pl_unscaled <- data.frame(CR = exp(unscaled_log_cr_pl), DBH = exp(unscaled_log_dbh_pl), sp = as.factor(stan_data_lr_cr$jj), community_fitted_CR_pl = community_fitted_cr_pl)

head(data_cr_pl_unscaled)

data_cr_gb <- data.frame(CR = exp(log_y_nlr), DBH = x_nlr, sp = sp_nlr)
head(data_cr_gb)

data_cr_gb$community_fitted_CR_gmm <- community_fitted_cr_gmm
data_cr_gb$community_fitted_CR_wb <- community_fitted_cr_wb

head(data_cr_pl_unscaled)
head(data_cr_gb)

# Combine the data frames
data_combined <- merge(data_cr_pl_unscaled, data_cr_gb, by = "sp", all = TRUE)
head(data_combined)

# Separate the community-fitted values for plotting
data_community_pl <- data_combined |> select(DBH.x, community_fitted_CR_pl) |> distinct()
data_community_gmm <- data_combined |> select(DBH.y, community_fitted_CR_gmm) |> distinct()
data_community_wb <- data_combined |> select(DBH.y, community_fitted_CR_wb) |> distinct()

head(data_community_pl)
head(data_community_gmm)
head(data_community_wb)

```

## Log scale plot with density based coloring (non-log scale)

```{r}
library(MASS)
library(dplyr)

head(data_combined)

# Calculate density
dens <- with(data_combined, kde2d(log(DBH.y), log(CR.y), n = 200))
ix <- findInterval(log(data_combined$DBH.y), dens$x)
iy <- findInterval(log(data_combined$CR.y), dens$y)
data_combined$density <- dens$z[cbind(ix, iy)]

head(data_combined)

combined_plot <- ggplot(data_combined) +
  geom_point(aes(x = DBH.y, y = CR.y, color = density), size = 0.5, alpha = 0.8) +
  geom_line(data = data_community_pl, aes(x = DBH.x, y = community_fitted_CR_pl), color = "blue", size = 1) +
  geom_line(data = data_community_gmm, aes(x = DBH.y, y = community_fitted_CR_gmm), color = "red", size = 1) +
  geom_line(data = data_community_wb, aes(x = DBH.y, y = community_fitted_CR_wb), color = "green", size = 1) +
  labs(title = "Community-level Model Fits for Power-law, gMM, and Weibull Models",
       x = "DBH (cm)",
       y = "CR (m)") +
  scale_x_log10(labels = scales::label_number()) +
  scale_y_log10(labels = scales::label_number()) +
  scale_color_gradientn(colors = c("black", "purple", "orange", "yellow"), name = "Density") +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 15),
    axis.text = element_text(size = 12),
    panel.grid = element_blank(),
    legend.position = "none"
  )

# Save the plot
ggsave(filename = "figs/cr/DBH_CR_community_combined_with_density.png", plot = combined_plot, width = 12, height = 8, dpi = 300, bg = "white")
```

## Non-log scale plot with density based coloring 

```{r}
# # Calculate density using kde2d and convert it to a data frame for plotting
# dens <- with(data_combined, kde2d(log(DBH.y), log(CR.y), n = 150))
# ix <- findInterval(log(data_combined$DBH.y), dens$x)
# iy <- findInterval(log(data_combined$CR.y), dens$y)
# data_combined$density <- dens$z[cbind(ix, iy)]

# Plotting with a smoother density representation
combined_plot2 <- ggplot(data_combined, aes(x = DBH.y, y = CR.y, color = density)) +
  geom_point(size = 0.5, alpha = 0.8) +
  geom_line(aes(x = DBH.x, y = community_fitted_CR_pl), color = "blue", size = 1, data = data_community_pl) +
  geom_line(aes(x = DBH.y, y = community_fitted_CR_gmm), color = "red", size = 1, data = data_community_gmm) +
  geom_line(aes(x = DBH.y, y = community_fitted_CR_wb), color = "green", size = 1, data = data_community_wb) +
  labs(title = "Community-level Model Fits for Power-law, gMM, and Weibull Models",
       x = "DBH (cm)",
       y = "CR (m)") +
  scale_color_gradientn(colors = c("black", "purple", "orange", "yellow"), name = "Density") +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 15),
    axis.text = element_text(size = 12),
    panel.grid = element_blank(),
    legend.position = "none"
  )

# Save the plot
ggsave(filename = "figs/cr/DBH_CR_community_combined_non_log.png", plot = combined_plot2, width = 12, height = 8, dpi = 300, bg = "white")
```


# DBH - CR*H

```{r}
# Load necessary libraries
library(ggplot2)
library(MASS)
library(reshape2)

# Data preparation
stan_data_lr_dbh1 <- tar_read(stan_data_lr_dbh1)
log_y <- stan_data_lr_dbh1$log_y
log_x <- stan_data_lr_dbh1$log_x[,2]
sp <- as.factor(stan_data_lr_dbh1$jj)

# Read in the model summary
dbh1 <- tar_read(fit_lr2_summary_power_law1_dbh1)

# Extract community-level parameters
community_log_a <- dbh1 |> filter(variable == "gamma[1,1]") |> pull(mean)
community_b <- dbh1 |> filter(variable == "gamma[2,1]") |> pull(mean)

community_fitted_log_y_dbh <- community_log_a + community_b * log_x
community_fitted_DBH <- exp(community_fitted_log_y_dbh)

# Create data frame for plotting
data_dbh1 <- data.frame(DBH = exp(log_y), CRxH = exp(log_x), sp = sp)
data_dbh1$community_fitted_DBH <- community_fitted_DBH

# Add species-specific fitted values
for (i in 1:length(log_a)) {
  data_dbh1[[paste0("fitted_DBH_sp_", i)]] <- fitted_dbh[, i]
}

# Reshape data for plotting
data_long <- melt(data_dbh1, id.vars = c("DBH", "CRxH", "sp", "community_fitted_DBH"), 
                  measure.vars = grep("fitted_DBH_sp_", names(data_dbh1), value = TRUE))

# Density Calculation
dens <- with(data_dbh1, kde2d(log(DBH), log(CRxH), n = 50))
ix <- findInterval(log(data_dbh1$CRxH), dens$x, all.inside = TRUE)
iy <- findInterval(log(data_dbh1$DBH), dens$y, all.inside = TRUE)
data_dbh1$density <- dens$z[cbind(ix, iy)]

# Plotting
dbh_plot1 <- ggplot(data_dbh1, aes(x = CRxH, y = DBH)) +
  geom_point(aes(color = density), alpha = 0.5) +
  geom_line(aes(x = CRxH, y = community_fitted_DBH), color = "white", linewidth = 1.2) +
  labs(title = "DBH = a*(CR*H)^b",
       x = "CR*H",
       y = "DBH") +
  scale_x_log10(labels = scales::label_number()) +
  scale_y_log10(labels = scales::label_number()) +
  scale_color_gradientn(colors = c("black", "purple", "orange", "yellow"), name = "Density") +
  theme_minimal()

# Save the plot
ggsave(filename = "figs/dbh/CR_CR*H_density.png", plot = dbh_plot1, width = 12, height = 8, dpi = 300, bg = "white")
```